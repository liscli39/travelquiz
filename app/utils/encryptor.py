"""This module contains a python class that was designed for encrypting sequential integer primary keys

    Typical usage example:

    # Generate a secret (done once)
    secret = PrimaryKeyEncryptor.generate_secret()

    # Instantiate encryptor = PrimaryKeyEncryptor(secret)

    # Encrypt
    encrypted = encryptor.encrypt(primary_key)

    # Decrypt
    decrypted_primary_key = encryptor.decrypt(encrypted)
"""
from os import urandom
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives.ciphers import Cipher
from cryptography.hazmat.primitives.ciphers.algorithms import TripleDES as Algorithm
from cryptography.hazmat.primitives.ciphers.modes import ECB as Mode
from django.conf import settings


class PrimaryKeyEncryptor:
    """This class uses TripleDES in ECB mode to generate a secure mapping between a 64-bit integer and a 16 characters hex
    string.

    Note:
        In many other contexts, the use of TripleDES in ECB mode is insecure. Please do not use this example for anything
        other than the exploit purpose of encrypting sequential integer primary keys generated by a storage engine.
    """

    def __init__(self, secret: str = settings.ENCRYPTOR_SECRET_KEY):
        """Initialize a PrimaryKeyEncryptor class.

        Args:
            secret: A 16 characters (8 bytes) hex string which is used as a key for encryption and decryption.

        Raises:
            ValueError: If the secret is not a 8 bytes hex string.
        """

        secret_bytes = bytes.fromhex(secret)

        if len(secret_bytes) != 8:
            raise ValueError('The secret for the PrimaryKeyEncryptor must be 8 bytes in hexadecimal format')

        algorithm = Algorithm(secret_bytes)
        mode = Mode()

        self.cipher = Cipher(algorithm, mode, backend=default_backend())

    @staticmethod
    def generate_secret() -> str:
        """Generate a secret that can be used to instantiate the PrimaryKeyEncryptor class.

        Returns:
            A 16 characters (8 bytes) hex string which is suitable to use as a key for encryption and decryption.
        """

        return urandom(8).hex()

    def encrypt(self, primary_key: int) -> str:
        """Encrypt an integer primary key

        Args:
            primary_key: An integer to encrypt, this cannot be more than 64 bits in size.

        Returns:
            The encrypted integer primary key as a 16 characters (8 bytes) hex string.

        Raises:
            ValueError: If the primary key is not an integer of 64 bits or fewer.
        """
        try:
            primary_key_bytes = primary_key.to_bytes(8, byteorder='big')

            encryptor = self.cipher.encryptor()

            cipher_bytes = encryptor.update(primary_key_bytes) + encryptor.finalize()

            return cipher_bytes.hex()
        except:
            return None

    def decrypt(self, encrypted_primary_key: str) -> int:
        """Encrypt an integer primary key

        Args:
            encrypted_primary_key: The encrypted integer primary key as a 16 characters (8 bytes) hex string.

        Returns:
            The decrypted integer primary key.

        Raises:
            ValueError: If the encrypted primary key is not valid.
        """
        try:
            cipher_bytes = bytes.fromhex(encrypted_primary_key)

            if len(cipher_bytes) != 8:
                raise ValueError('The encrypted primary key must be 8 bytes in hexadecimal format')

            decryptor = self.cipher.decryptor()

            plain_bytes = decryptor.update(cipher_bytes) + decryptor.finalize()

            return int.from_bytes(plain_bytes[:8], byteorder='big')
        except:
            return None
